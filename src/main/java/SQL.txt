// 608. Tree Node
SELECT t.id,
    CASE
    WHEN t.p_id IS NULL THEN 'Root'
    WHEN t.p_id IS NOT NULL AND t.id IN (
        SELECT sub.p_id
        FROM Tree sub
    ) THEN 'Inner'
    ELSE 'Leaf'
    END AS type
FROM Tree t
;

// 626. Exchange seats
// моя версия
SELECT CASE
    WHEN (id%2) = 0 THEN (id-1)
    WHEN (id%2) != 0 AND id !=(SELECT MAX(id)
        FROM Seat) THEN (id+1)
    ELSE id
    END AS id,
    student
FROM Seat
GROUP BY id, student
ORDER BY id
;

// solution. row_number() over считает строки,
// внутри идет сортировка по измененным id
// последний нечетный id тоже меняется (при 5 элементах не будет id 5, там будут 4 и 6)
// но выводится-то счетчик, а не id.  Так что выведется "правильный" порядок и без ошибки последнего номера
SELECT
    ROW_NUMBER() OVER(
        ORDER BY
        (CASE WHEN id % 2 = 0 THEN id - 1 ELSE id + 1 END)
    ) AS id, student
FROM Seat

// 1729. Find Followers Count
SELECT user_id, COUNT(follower_id) AS followers_count
FROM Followers
GROUP BY user_id
ORDER BY user_id
;

//1393. Capital Gain/Loss
SELECT stock_name,
    SUM((CASE
        WHEN operation ='Buy' THEN -price
        ELSE price
        END)::numeric) AS capital_gain_loss
FROM Stocks
GROUP BY stock_name
;

// 1667. Fix names in table
// как вариант в решениях предлагают через substring: он умеет "от индекса до индекса" и просто "от"
// т.е. получается substring(name, 1, 1) и substring(name, 2)
// выглядит покороче и на один вызов меньше (не надо запрашивать отдельно длину строки)
SELECT user_id, CONCAT(UPPER(LEFT(name,1)),LOWER(RIGHT(name, LENGTH(name)-1))) AS name
FROM Users
ORDER BY user_id
;

// 1795. Rearrange products table
--- UNNEST ---
https://www.w3resource.com/PostgreSQL/postgresql_unnest-function.php

SELECT
    product_id,
    store,
    price
FROM (
  SELECT
    product_id,
    UNNEST(ARRAY['store1', 'store2', 'store3']) AS store,
    UNNEST(ARRAY[store1, store2, store3]) AS price
  FROM
    Products
) AS unpivot
WHERE price IS NOT NULL

// MySQL ----- UNION ------
SELECT product_id, 'store1' AS store, store1 AS price
FROM Products
WHERE store1 IS NOT NULL
UNION
SELECT product_id, 'store2' AS store, store2 AS price
FROM Products
WHERE store2 IS NOT NULL
UNION
SELECT product_id, 'store3' AS store, store3 AS price
FROM Products
WHERE store3 IS NOT NULL

// 176. Second Highest Salary
// LIMIT and OFFSET allow you to retrieve just a portion of the rows that are generated by the rest of the query
------- OFFSET says to skip that many rows before beginning to return rows
// The rows skipped by an OFFSET clause still have to be computed inside the server;
// therefore a large OFFSET might be inefficient.

SELECT
    (SELECT DISTINCT salary
     FROM Employee
     ORDER BY salary DESC --- Otherwise you will get an unpredictable subset of the query's rows.
     OFFSET 1 LIMIT 1)
AS SecondHighestSalary;

// 1661. Average Time of Process per Machine
Задание такое, что я смогла придумать только многоэтажные подзапросы.
Решив, что это не похоже на красивый литкод, пошла в солюшен. И вот что нашла:
-- AVG разделит на количество строк. На каждый процесс этих строк 2,
то есть 2 процесса, 4 строки.
Но вычетание из конца начала у нас происходит за счет смены знака начала,
так что разделить-то надо все же на число процессов.
Поэтому возникает умножение на 2 после деления AVG на удвоенное число строк.
Математический выебон и воспринять чуть сложнее, с другой стороны, если это запрос не на разовый отчет,
а внутри кода вызывается регулярно - то съекономить 5(кажется, 5) подзапросов - есть смысл...

SELECT  machine_id,
        ROUND(
            AVG(
            CASE
                WHEN activity_type = 'start' THEN -timestamp
                ELSE timestamp
            END)::decimal * 2 -- there are two rows per process_id
            , 3) AS processing_time
FROM Activity
GROUP BY machine_id
ORDER BY machine_id ASC;

// 1527. Patients with a condition
SELECT *
FROM Patients
WHERE conditions LIKE '% DIAB1%'
    OR conditions LIKE 'DIAB1%'
;

// 1890 The Latest Login in 2020
WHERE vs HAVING
where можно, а на having ругается, что еще и в group by запихни, что мне не прокатывает

SELECT user_id,
    MAX(time_stamp) AS last_stamp
FROM Logins
WHERE time_stamp::date BETWEEN '2020-01-01' AND '2020-12-31'
GROUP BY user_id
--HAVING EXTRACT(YEAR FROM time_stamp::date) = 2020
;

// 1683. Invalid Tweets
SELECT tweet_id
FROM Tweets
WHERE LENGTH(content) > 15
;

// 1517. Find Users With Valid Emails
---REGEX--- (regular expression) ... LIKE в данном случае не подойдет.
лайк для проверки маски слова, (_ для char и % для string, добавляешь обязательные буквы где ожидаются)
То есть в случае с мылом можно сказать %@gmail.com если мы принимаем для регистрации только мыльники
с жмыла, но этот паттерн не проверит корректность ника, только что после собаки верный домен.
До собаки в таком случае будет допустимо любое число любых символов (лишь бы хоть что-то было).
Для соответствия допустимым символам - только регулярные выражения

SELECT *
FROM Users
WHERE mail ~ '^[a-zA-Z]+[a-zA-Z0-9_.-]*@leetcode\.com$'
;

// 1484. Group Sold Products By the date
--- STRING_AGG --- обязательны источник и разделитель, сортировка опционально
--- STRING_AGG ( expression, separator [order_by_clause] )
--- в документации еще пример:
STRING_AGG (
	a.first_name || ' ' || a.last_name, --- вот тут склейка из разных полей с пробелом и считается одним блоком
	--- (отделяется запятой, указанным сепаратором)
        ','
       ORDER BY
        a.first_name,
        a.last_name
    ) actors


SELECT sell_date,
    COUNT(DISTINCT product) AS num_sold,
    STRING_AGG(DISTINCT product, ',' ORDER BY product) AS products
FROM Activities
GROUP BY sell_date
ORDER BY sell_date
;

// 1407 Top Travellers
SELECT u.name AS name,
    COALESCE(SUM(distance), 0) AS travelled_distance
FROM Users AS u
LEFT JOIN Rides AS r ON u.id=r.user_id
GROUP BY u.id, name
ORDER BY
    travelled_distance DESC,
    name ASC
;

// 1378 Replace Employee ID
SELECT u.unique_id AS unique_id,
    e.name AS name
FROM Employees AS e
LEFT JOIN EmployeeUNI AS u ON e.id=u.id
;

// 1327. List the Products Ordered in a Period
SELECT p.product_name AS product_name,
        SUM(o.unit) AS unit
FROM Products AS p
LEFT JOIN Orders AS o ON p.product_id=o.product_id
WHERE CAST (o.order_date AS DATE) BETWEEN '2020-02-01' AND '2020-02-29'
GROUP BY p.product_name
HAVING SUM(o.unit) >= 100
;

v2 (SOLUTION)
SELECT  p.product_name,
        SUM(o.unit) AS unit
FROM Products AS p
    JOIN Orders AS o
    ON p.product_id = o.product_id
    AND  EXTRACT(YEAR FROM o.order_date) = 2020
    AND EXTRACT(MONTH FROM o.order_date) = 2
GROUP BY 1
HAVING SUM(o.unit)>=100

// 1280 Students and Examinations
select s.student_id, s.student_name, su.subject_name, COUNT(e.subject_name) AS attended_exams
from students as s
cross join subjects as su
left join  examinations e ON s.student_id = e.student_id AND su.subject_name = e.subject_name
group by s.student_id, s.student_name, su.subject_name
order by s.student_id, su.subject_name
;

// 1251. Average Selling Price
// COALESCE(field1, field2 ... , 0) будет использовать те значения полей, что не NULL,
// либо подставит указанный 0. Этому оператору нужно только, чтобы все поля были приводимы к одному типу

SELECT p.product_id AS product_id,
    COALESCE(ROUND(SUM(us.units::numeric*price) / SUM(us.units::numeric), 2), 0) AS average_price
FROM Prices AS p
LEFT JOIN UnitsSold AS us ON p.product_id = us.product_id
    AND us.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY p.product_id;

// 1211. Queries Quality and Percentage
---------NUMERIC---------
// Нужно из целого сделать с точкой? Есть число в выражении, поставь его первым и добавь точку
// Не можешь начать с числа, добавь ::numeric первому члену выражения

SELECT query_name,
       ROUND(SUM(rating::numeric / position) / COUNT(result), 2) AS quality,
       ROUND(100. * COUNT(rating) FILTER ( WHERE rating < 3 ) / COUNT(rating), 2) poor_query_percentage
FROM Queries
WHERE query_name IS NOT NULL
GROUP BY query_name
;

// 1179. Reformat department Table
// Solution - мне было сразу ясно, что
// я смогу это сделать только в 12 подзапросов,
// а это явно не то, что надо
// знакомлюсь: FILTER (CASE тоже можно, но хуже)
// не знаю, кто это делает, но если считать нечего, то выводится NULL
// кто делает через CASE, пишет сам NULL:
// CASE WHEN month = 'Jan' THEN revenue ELSE null END

SELECT
  id,
  MAX(revenue) FILTER (WHERE month = 'Jan') AS Jan_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Feb') AS Feb_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Mar') AS Mar_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Apr') AS Apr_Revenue,
  MAX(revenue) FILTER (WHERE month = 'May') AS May_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Jun') AS Jun_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Jul') AS Jul_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Aug') AS Aug_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Sep') AS Sep_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Oct') AS Oct_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Nov') AS Nov_Revenue,
  MAX(revenue) FILTER (WHERE month = 'Dec') AS Dec_Revenue
FROM
  Department
GROUP BY
  id;

// 1148. Article Views
// v1 1070ms
SELECT author_id AS id
FROM Views
WHERE author_id = viewer_id
GROUP BY author_id
ORDER BY author_id
;

//v2 377ms
SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY author_id
;

// 1141. User Activity
--v1 504 ms
SELECT activity_date AS day,
     COUNT(DISTINCT user_id) AS active_users
FROM Activity
GROUP BY activity_date
HAVING CAST(activity_date AS DATE) BETWEEN '2019-06-28' AND '2019-07-27'
;

--v2 403 ms
SELECT activity_date AS day,
     COUNT(DISTINCT user_id) AS active_users
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND '2019-07-27'
GROUP BY activity_date
;

// Sales Analysis 1084
SELECT DISTINCT p.product_id AS product_id,
    p.product_name AS product_name
FROM Product AS p
LEFT JOIN Sales AS s ON p.product_id=s.product_id
WHERE CAST(s.sale_date AS date) BETWEEN '2019-01-01' AND '2019-03-31'
AND s.product_id NOT IN (
    SELECT product_id
    FROM Sales
    WHERE CAST(sale_date AS DATE) > '2019-03-31'
    OR CAST(sale_date AS DATE) < '2019-01-01'
)
;

// 1075. Project Employees I
SELECT p.project_id AS project_id,
-- 2 в ROUND это сколько цифр после запятой оставлять после округления
        ROUND(AVG(e.experience_years),2) AS average_years
FROM Project AS p
LEFT JOIN Employee AS e ON p.employee_id=e.employee_id
GROUP BY p.project_id
;

// 627. Swap Salary
UPDATE Salary --table name
SET sex = -- column name
    CASE
        WHEN sex='f' THEN 'm'
        ELSE 'f'
    END
;

// 619. Biggest Single Number
SELECT MAX(num) AS num
FROM MyNumbers
WHERE num NOT IN
    (SELECT *
    FROM MyNumbers
    GROUP BY num
    HAVING COUNT(num)>1)
;

// 610. Triangle Judgement
SELECT *,
    CASE
        WHEN (x+y)>z AND (x+z)>y AND (z+y)>x THEN 'Yes'
        ELSE 'No'
    END AS triangle
FROM Triangle
;

// 607. SALES Person
SELECT name
FROM SalesPerson
WHERE sales_id NOT IN (
    SELECT sales_id
    FROM Orders o
    JOIN Company c ON o.com_id = c.com_id
    WHERE c.name = 'RED'
)
;

// 596. Classes More Than 5 Students
SELECT class
FROM Courses
GROUP BY class
HAVING COUNT(student) >= 5
;

// 595. Big Countries
SELECT w.name AS name,
        w.population AS population,
        w.area AS area
FROM World AS w
WHERE w.area >= 3000000 OR w.population >= 25000000
;

// 584. Find Customer Referee
SELECT c.name AS name
FROM Customer AS c
WHERE c.referee_id != 2 OR c.referee_id IS NULL
;

// 577. Employee Bonus
SELECT e.name AS name,
    b.bonus AS bonus
FROM Employee AS e
FULL JOIN Bonus AS b
ON e.empId = b.empId
WHERE b.bonus < 1000 OR b.bonus IS NULL
;

// 511. Game Play Analysis I
SELECT player_id,
    MIN(event_date) AS first_login
FROM Activity
GROUP BY player_id
ORDER BY player_id;

// 197. Rising Temperature
v2 // works
SELECT w1.id
FROM Weather as w1 full JOIN Weather as w2 ON (w1.recordDate - 1)=(w2.recordDate)
WHERE w1.temperature > w2.temperature;

v1 // Не работает, т.к. в скрытых тестах даты могут быть перемешаны
SELECT w1.id
FROM Weather as w1 full JOIN Weather as w2 ON (w1.id - 1)=(w2.id)
WHERE w1.temperature > w2.temperature;

// 196. Delete Duplicate Emails
v1
DELETE FROM Person AS p
WHERE p.id IN
(SELECT p1.id FROM Person as p1 INNER JOIN Person as p2
ON p1.email = p2.email
WHERE p1.id > p2.id);

v2
DELETE FROM Person
WHERE id NOT IN (select MIN(id) from Person GROUP BY email);

// 175. Combine Two Tables
SELECT p.firstName, p.lastName, a.city, a.state
FROM Person AS p LEFT JOIN Address AS a ON p.personId = a.personId;

// 181. Employees Earning More Than Their Managers
SELECT e.name AS Employee
FROM Employee AS e INNER JOIN Employee AS m ON e.managerId = m.id
WHERE e.salary > m.salary;

// 182. Duplicate Emails
v1
SELECT email from Person
group by email
having count(email) > 1;

v2 // <> не равно, отличаются, != тоже работает
SELECT DISTINCT(p1.email) from Person p1, Person p2
where p1.id <> p2.id AND p1.email = p2.email;

// 183. Customers who never order
v1
SELECT c.name AS Customers
FROM Customers AS c FULL JOIN Orders AS o ON c.id = o.customerId
WHERE o.id IS NULL;

v2
SELECT c.name AS Customers
FROM Customers AS c
WHERE c.id NOT IN (
SELECT customerId
FROM Orders);